# Embedding with Go
Gain performance, reliability and flexibility


Loh Siu Yin
Engineer, Beyond Broadcast LLP
siuyin@beyondbroadcast.com

## A simple production ready web API with Go

## /hello API endpoint
.code 01_web/main.go

demo:
```
go run ./01_web/

hey -n 1000 -c 4 http://localhost:8080/hello
```

## How about a minimal frontend?

## net/http FileServer
.code -numbers 02_frontend/main.go

Line 9: Serve files in `./public` at `/`.

## index.html
.code -numbers 02_frontend/public/index.html
External files: Lines 4, 12 and index.html itself.

demo:
```
cd 02_frontend
go run .
http://localhost:8080/
```

## Deployment packaging options
- Docker container image:  
  Use a minimal image like gcr.io/distroless/static-debian12  
  Copy the public html, javacript and css along with the Go binary  
  into the container image.
- Static binary:  
  GOOS=windows GOARCH=amd64 go build -o mybin *.go  
  go tool dist list

What are the Pros and Cons of each deployment packaging method?


## Embedding
03_embed/main.go:

.code 03_embed/main.go /import/,/public/
â‹®

.code 03_embed/main.go /main\(\)/,/FileServerFS/


03_embed/public/public.go:

.code 03_embed/public/public.go

## 
demo:

```
go run ./03_embed/
hey -n 1000 -c 8 http://localhost:8080/
hey -n 1000 -c 8 http://localhost:8080/hello
```

## Objection! `real` APIs are not like /hello

They take much more than 1 milli-second to complete!

For example, order processing has to check the inventory database,
perhaps located on a separate system. And may
be require a **series** of API calls to execute.

demo: perhaps like this...
```
go run ./04_stream/
curl 'http://localhost:8080/proc?id=A&n=10' && curl 'http://localhost:8080/proc?id=B&n=10'

http://localhost:8080/
```

What would happen if we terminate the program in the mid-processing?  
A. DB corruption. Cannot recover.  
B. State lost. Items remaining to be processed are not handled.  
C. Interrupted item corrupted and not processed. Continue processing next item.  
D. Interrupted item retried and processsing continues.

## Embed a NATS message streaming server
.code -numbers 04_stream/main.go /init/,/Fatal/+1

Line 23: The secret is to **embed** a NATS JetStream server.  
Line 30: Let us first focus how the processing was done during the demo.

## procHandler: parse id and n
.code -numbers 04_stream/main.go /func procHandler/,/Atoi/+3

Line 75: This is a standard Go `net/http` handler.

## procHandler: publish to "proc" stream
.code -numbers 04_stream/main.go /Atoi/+3,/^}/

Line 87: get a JetStream instance.  
Line 96: Publish to `"proc"` topic.

## procWorker works the "proc" stream
.code -numbers 04_stream/main.go /func procWorker/,/^}/

Line 42: Delay to simulate cpu-instensive work.  
Line 44: Each message is explicitly acknowledged only after sucessful processing

## Wait: there is even more ...
demo:
```
go run ./04_stream/

curl -X POST 'http://localhost:8080/stor?k=a&v=apple'
curl -X POST 'http://localhost:8080/stor?k=b&v=boy'

curl 'http://localhost:8080/stor?k=a'
curl 'http://localhost:8080/stor?k=b'
```

## /stor endpoint: create a key-value store
.code -numbers 04_stream/main.go /func storHandler/,/switch/-1

Line 133: The key-value store is built on JetStream.  
Line 140: That JetStream instance is used to create the KV store.

## /stor endpoint: put and get
.code -numbers 04_stream/main.go /r.Method/,/default:/-1

Line 148: Get operation.  
Line 158: Put operation.

## Recap
- Go has embedding and concurrency capabilities,  
  enabling a micro-service pattern but  
  encapsulated within a single binary deliverable.

- Go's `embed` standard library function embeds  
  HTML, javascript, css or other aribitrary files  
  within a single compiled binary.

- NATS is a Go embeddable library that provides  
  messages streaming and queuing, key-value and object stores.  
    
  This enables CQRS (Command / Query Responsibility Segregation),  
  choreography and orchestration patterns for event-driven systems.

## Source code:

https://github.com/siuyin/present_embed_go

